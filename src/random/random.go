// Copyright 2014 Markus Dittrich. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//
// random wraps gsl random number generation routines
package random

// #cgo pkg-config: gsl
// #include <gsl/gsl_rng.h>
import "C"

import (
  "runtime"
  "unsafe"
)


// RngState stores the random number generator state
type RngState struct {
  state *C.gsl_rng
}

// RngType stores the type of rng method used
type RngType *C.gsl_rng_type

// StatePointer encapsulates a raw pointer to the underlying
// rng state within gsl
type StatePointer unsafe.Pointer


// list of defined random number generators. See gsl documentation
// for more detailed info on each of these.
var (
  Mt19937 RngType = C.gsl_rng_mt19937
  Ranlxs0 RngType = C.gsl_rng_ranlxs0
  Ranlxs1 RngType = C.gsl_rng_ranlxs1
  Ranlxs2 RngType = C.gsl_rng_ranlxs2
  Ranlxd1 RngType = C.gsl_rng_ranlxd1
  Ranlxd2 RngType = C.gsl_rng_ranlxd2
  Ranlux RngType = C.gsl_rng_ranlux
  Ranlux389 RngType =  C.gsl_rng_ranlux389
  Cmrg RngType = C.gsl_rng_cmrg
  Mrg RngType = C.gsl_rng_mrg
  Taus RngType = C.gsl_rng_taus
  Taus2 RngType = C.gsl_rng_taus2
  Gfsr4 RngType = C.gsl_rng_gfsr4

  // Unix type rngs - these are not high quality so beware
  Rand RngType = C.gsl_rng_rand
  RandomBSD RngType = C.gsl_rng_random_bsd
  RandomBSD_8 RngType = C.gsl_rng_random8_bsd
  RandomBSD_32 RngType = C.gsl_rng_random32_bsd
  RandomBSD_64 RngType = C.gsl_rng_random64_bsd
  RandomBSD_28 RngType = C.gsl_rng_random128_bsd
  RandomBSD_256 RngType = C.gsl_rng_random256_bsd

  RandomLibc5 RngType = C.gsl_rng_random_libc5
  RandomLibc5_8 RngType = C.gsl_rng_random8_libc5
  RandomLibc5_32 RngType = C.gsl_rng_random32_libc5
  RandomLibc5_64 RngType = C.gsl_rng_random64_libc5
  RandomLibc5_128 RngType = C.gsl_rng_random128_libc5
  RandomLibc5_256 RngType = C.gsl_rng_random256_libc5

  RandomGlibc2 RngType = C.gsl_rng_random_glibc2
  RandomGlibc2_8 RngType = C.gsl_rng_random8_glibc2
  RandomGlibc2_32 RngType = C.gsl_rng_random32_glibc2
  RandomGlibc2_64 RngType = C.gsl_rng_random64_glibc2
  RandomGlibc2_128 RngType = C.gsl_rng_random128_glibc2
  RandomGlibc2_256 RngType = C.gsl_rng_random256_glibc2

  Rand48 RngType = C.gsl_rng_rand48

  // compatibility rng types - typically low quality 
  Ranf RngType = C.gsl_rng_ranf
  Ranmar RngType = C.gsl_rng_ranmar
  R250 RngType = C.gsl_rng_r250
  Tt800 RngType = C.gsl_rng_tt800
  Vax RngType = C.gsl_rng_vax
  Transputer RngType = C.gsl_rng_transputer
  Randu RngType = C.gsl_rng_randu
  Minstd RngType = C.gsl_rng_minstd
  Uni RngType = C.gsl_rng_uni
  Uni32 RngType = C.gsl_rng_uni32
  Slatec RngType = C.gsl_rng_slatec
  Zuf RngType = C.gsl_rng_zuf
  Knuthran2 RngType = C.gsl_rng_knuthran2
  Knuthran2002 RngType = C.gsl_rng_knuthran2002
  Knuthran RngType = C.gsl_rng_knuthran
  Borosh13 RngType = C.gsl_rng_borosh13
  Fishman18 RngType = C.gsl_rng_fishman18
  Fishman20 RngType = C.gsl_rng_fishman20
  Lecuyer21 RngType = C.gsl_rng_lecuyer21
  Waterman14 RngType = C.gsl_rng_waterman14
  Fishman2x RngType = C.gsl_rng_fishman2x
  Coveyou RngType = C.gsl_rng_coveyou
)


// RNG initialization

// Default returns the default random number generator
func Default() RngType {
  return C.gsl_rng_default
}

// Alloc creates a new random number generator and returs
// it as a RngState object.
func Alloc(rngType RngType) RngState {
  state := RngState{C.gsl_rng_alloc(rngType)}

  // make sure we get rid of any memory associated with the
  // rng within gsl
  runtime.SetFinalizer(&state,
    func (rng *RngState) { C.gsl_rng_free(rng.state) })
  return state
}


// Set initializes (or ‘seeds’) the random number generator. If the
// generator is seeded with the same value of seed on two different runs,
// the same stream of random numbers will be generated by successive calls
// to the routines below. If different values of seed ≥ 1 are supplied,
// then the generated streams of random numbers should be completely
// different. If the seed seed is zero then the standard seed from the
// original implementation is used instead. For example, the original
// Fortran source code for the ranlux generator used a seed of 314159265,
// and so choosing seed equal to zero reproduces this when using
// gsl_rng_ranlux.
//
// When using multiple seeds with the same generator, choose seed values
// greater than zero to avoid collisions with the default setting.
// Note that the most generators only accept 32-bit seeds, with higher
// values being reduced modulo 2^32 . For generators with smaller ranges
// the maximum seed value will typically be lower.
func (s RngState) Set(seed uint64) {
  C.gsl_rng_set(s.state, C.ulong(seed))
}


// RNG sampling functions


// Get returns a random integer from the generator s. The minimum and
// maximum values depend on the algorithm used, but all integers in the
// range [min,max] are equally likely. The values of min and max can be
// determined using the auxiliary functions Max and Min.
func (s RngState) Get() float64 {
  return float64(C.gsl_rng_get(s.state))
}


// Uniform returns a double precision floating point number
// uniformly distributed in the range [0,1). The range includes 0.0 
// but excludes 1.0.
func (s RngState) Uniform() float64 {
  return float64(C.gsl_rng_uniform(s.state))
}


// UniformPos function returns a positive double precision floating point
// number uniformly distributed in the range (0,1), excluding both 0.0 and
// 1.0. The number is obtained by sampling the generator with the algorithm
// of Uniform until a non-zero value is obtained. You can use this function
// if you need to avoid a singularity at 0.0.
func (s RngState) UniformPos() float64 {
  return float64(C.gsl_rng_uniform_pos(s.state))
}


// UniformInt returns a random integer from 0 to n − 1 inclusive by scaling
// down and/or discarding samples from the generator r. All integers in the
// range [0, n − 1] are produced with equal probability. For generators with
// a non-zero minimum value an offset is applied so that zero is returned
// with the correct probability. Note that this function is designed for
// sampling from ranges smaller than the range of the underlying generator.
// The parameter n must be less than or equal to the range of the generator r.// If n is larger than the range of the generator then the function
// calls the error handler with an error code of GSL_EINVAL and returns zero.
// In particular, this function is not intended for generating the full range 
// of unsigned integer values [0, 2 32 − 1]. Instead choose a generator with
// the maximal integer range and zero minimum value, such as gsl_rng_ranlxd1,
// gsl_rng_mt19937 or gsl_rng_taus, and sample it directly using gsl_rng_get.
// The range of each can be found with the help of auxiliary sections.
func (s RngState) UniformInt(limit uint64) uint64 {
  return uint64(C.gsl_rng_uniform_int(s.state, C.ulong(limit)))
}


// RNG auxiliary functions

// Name returns the name of the random number generator
func (s RngState) Name() string {
  return C.GoString(C.gsl_rng_name(s.state))
}


// String provides a printable string representation for
// an RngState
func (s RngState) String() string {
  return s.Name()
}

// Max returns the largest value that the rng underlying RngState
// can handle
func (s RngState) Max() uint64 {
  return uint64(C.gsl_rng_max(s.state))
}

// Min returns the largest value that the rng underlying RngState
// can handle
func (s RngState) Min() uint64 {
  return uint64(C.gsl_rng_min(s.state))
}

// State returns a pointer to the underlying rng state from gsl
func (s RngState) State() StatePointer {
  return StatePointer(C.gsl_rng_state(s.state))
}

// Size returns the size of the rng state.
func (s RngState) Size() uint64 {
  return uint64(C.gsl_rng_size(s.state))
}


// TypesSetup returns a slice with all available generator types
//func TypesSetup() []RngType {
//  types := []RngType(C.gsl_rng_types_setup())
//
//  return types
//}

