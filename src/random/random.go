// Copyright 2014 Markus Dittrich. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//
// random wraps gsl random number generation routines
package random

// #cgo pkg-config: gsl
// #include <gsl/gsl_rng.h>
import "C"

import (
  "runtime"
  "unsafe"
)


// RngState stores the random number generator state
type RngState struct {
  state *C.gsl_rng
}

// RngType stores the type of rng method used
type RngType *C.gsl_rng_type

// StatePointer encapsulates a raw pointer to the underlying
// rng state within gsl
type StatePointer unsafe.Pointer


// list of defined random number generators. See gsl documentation
// for more detailed info on each of these.
var (
  Mt19937 RngType = C.gsl_rng_mt19937
  Ranlxs0 RngType = C.gsl_rng_ranlxs0
  Ranlxs1 RngType = C.gsl_rng_ranlxs1
  Ranlxs2 RngType = C.gsl_rng_ranlxs2
  Ranlux RngType = C.gsl_rng_ranlux
)


// RNG initialization

// Default returns the default random number generator
func Default() RngType {
  return C.gsl_rng_default
}

// Alloc creates a new random number generator and returs
// it as a RngState object.
func Alloc(rngType RngType) RngState {
  state := RngState{C.gsl_rng_alloc(rngType)}

  // make sure we get rid of any memory associated with the
  // rng within gsl
  runtime.SetFinalizer(&state,
    func (rng *RngState) { C.gsl_rng_free(rng.state) })
  return state
}


// Set initializes (or ‘seeds’) the random number generator. If the
// generator is seeded with the same value of seed on two different runs,
// the same stream of random numbers will be generated by successive calls
// to the routines below. If different values of seed ≥ 1 are supplied,
// then the generated streams of random numbers should be completely
// different. If the seed seed is zero then the standard seed from the
// original implementation is used instead. For example, the original
// Fortran source code for the ranlux generator used a seed of 314159265,
// and so choosing seed equal to zero reproduces this when using
// gsl_rng_ranlux.
//
// When using multiple seeds with the same generator, choose seed values
// greater than zero to avoid collisions with the default setting.
// Note that the most generators only accept 32-bit seeds, with higher
// values being reduced modulo 2^32 . For generators with smaller ranges
// the maximum seed value will typically be lower.
func (s RngState) Set(seed uint64) {
  C.gsl_rng_set(s.state, C.ulong(seed))
}


// RNG sampling functions


// Get returns a random integer from the generator s. The minimum and
// maximum values depend on the algorithm used, but all integers in the
// range [min,max] are equally likely. The values of min and max can be
// determined using the auxiliary functions Max and Min.
func (s RngState) Get() float64 {
  return float64(C.gsl_rng_get(s.state))
}


// Uniform returns a double precision floating point number
// uniformly distributed in the range [0,1). The range includes 0.0 
// but excludes 1.0.
func (s RngState) Uniform() float64 {
  return float64(C.gsl_rng_uniform(s.state))
}


// UniformPos function returns a positive double precision floating point
// number uniformly distributed in the range (0,1), excluding both 0.0 and
// 1.0. The number is obtained by sampling the generator with the algorithm
// of Uniform until a non-zero value is obtained. You can use this function
// if you need to avoid a singularity at 0.0.
func (s RngState) UniformPos() float64 {
  return float64(C.gsl_rng_uniform_pos(s.state))
}


// UniformInt returns a random integer from 0 to n − 1 inclusive by scaling
// down and/or discarding samples from the generator r. All integers in the
// range [0, n − 1] are produced with equal probability. For generators with
// a non-zero minimum value an offset is applied so that zero is returned
// with the correct probability. Note that this function is designed for
// sampling from ranges smaller than the range of the underlying generator.
// The parameter n must be less than or equal to the range of the generator r.// If n is larger than the range of the generator then the function
// calls the error handler with an error code of GSL_EINVAL and returns zero.
// In particular, this function is not intended for generating the full range 
// of unsigned integer values [0, 2 32 − 1]. Instead choose a generator with
// the maximal integer range and zero minimum value, such as gsl_rng_ranlxd1,
// gsl_rng_mt19937 or gsl_rng_taus, and sample it directly using gsl_rng_get.
// The range of each can be found with the help of auxiliary sections.
func (s RngState) UniformInt(limit uint64) uint64 {
  return uint64(C.gsl_rng_uniform_int(s.state, C.ulong(limit)))
}


// RNG auxiliary functions

// Name returns the name of the random number generator
func (s RngState) Name() string {
  return C.GoString(C.gsl_rng_name(s.state))
}


// String provides a printable string representation for
// an RngState
func (s RngState) String() string {
  return s.Name()
}

// Max returns the largest value that the rng underlying RngState
// can handle
func (s RngState) Max() uint64 {
  return uint64(C.gsl_rng_max(s.state))
}

// Min returns the largest value that the rng underlying RngState
// can handle
func (s RngState) Min() uint64 {
  return uint64(C.gsl_rng_min(s.state))
}

// State returns a pointer to the underlying rng state from gsl
func (s RngState) State() StatePointer {
  return StatePointer(C.gsl_rng_state(s.state))
}

// Size returns the size of the rng state.
func (s RngState) Size() uint64 {
  return uint64(C.gsl_rng_size(s.state))
}


// TypesSetup returns a slice with all available generator types
//func TypesSetup() []RngType {
//  types := []RngType(C.gsl_rng_types_setup())
//
//  return types
//}

